## MySql整理面试题汇总

* [Mysql常见的存储引擎有几种？分别有什么区别？](#Mysql常见的存储引擎有几种分别有什么区别)
* [Mysql都有哪些锁？什么业务下使用合适？](#Mysql都有哪些锁什么业务下使用合适)
* [什么是死锁？怎么解决？](#什么是死锁怎么解决)
* [什么是乐观锁？悲观锁？实现方式？](#什么是乐观锁悲观锁实现方式)
* [聚集索引与非聚集索引？](#聚集索引与非聚集索引)
* [Mysql都有哪些索引？](#Mysql都有哪些索引)
* [索引算法有那些？有什么区别](#索引算法有那些有什么区别)
* [什么是事务？](#什么是事务)
* [什么是脏读？什么是幻读？不可重复读？](#什么是脏读什么是幻读不可重复读)
* [Mysql数据隔离级别](#Mysql数据隔离级别)

### Mysql常见的存储引擎有几种？分别有什么区别？

1. InnoDB：支持行级锁定、支持事务、支持外键约束，支持自动增长列；不支持全文检索 (5.5.8之后是默认存储引擎)
2. MyISAM：全表锁，不支持事务、不支持外键，读写速度快、支持全文检索 (5.5.8之前是默认存储引擎)
3. Memory：全表锁，将表数据存储在内存中，表结构以文件存于磁盘中。访问速度非常快，数据在MySQL重启或崩溃时会丢失。要求存储数据长度不可变

| 功能 | MyISAM | Memory | InnoDB |
| -- | -- | -- | -- |
| 存储限制 | 256TB | RAM | 64TB |
| 支持事务 | No | No | Yes |
| 支持全文检索 | Yes | No | No |
| 支持数索引 | Yes | Yes | Yes |
| 支持哈希索引 | No | Yes | No |
| 支持数据缓存 | No | N/A | Yes |
| 支持外键 | No | No | Yes | 

使用场景：

- InnoDB：
    - 需要事务支持(具有较好的事务特性)
    - 行级锁定对高并发有很好的适应能力，但需要确保查询是通过索引完成
    - 数据更新较为频繁的场景
    - 数据一致性要求高
    - 硬件设备内存较大，可以利用InnoDB较好的缓存能力来提高内存利用率，尽可能减少磁盘IO

- MyISAM：
    - 不需要事务支持(不支持)
    - 并发相对较低(锁定机制问题)
    - 数据修改相对较少(阻塞问题)
    - 以读为主
    - 数据一致性要求不是非常高

- Memory：
    - 数据安全性要求不高
    - 一次性数据
    - 读写速度要求非常快
    - 需要建立一个临时查询的表


### Mysql都有哪些锁？什么业务下使用合适？

在DBMS中，按照颗粒程度可以把分为行级锁(InnoDB引擎)、表级锁(MyISAM引擎)、页级锁定(BDB引擎)

1. 行级锁

    a) 描述：Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行锁定。行级锁能大大减少数据库操作的冲突，其加锁粒度最小，但加锁的开销最大。行级锁分别为**共享锁**和**排他锁**

    b) 特点：开销大，加锁慢，会出现死锁。发生锁冲突的概率低，并发度也最高。

2. 表级锁

    a) 描述：mysql中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分mysql引擎支持。最常使用的MyISAM与InnoDB都支持表级锁定。表级锁分别为**共享锁**和**排他锁**

    b) 特点：开销小，加锁快，不会出现死锁。发生锁冲突的概率最高，并发度也最低。

3. 页级锁

    a) 描述：页级锁是MySQL中锁定粒度介于行级锁与表级锁中间的一种锁。但冲突多，行级冲突少，速度慢

    b) 特点：开销和加锁时间介于表锁和行锁之间；会出现死锁；锁定粒度介于表锁和行锁之间，并发度一般


| | 行级锁 | 表级锁 | 页级锁 |
| -- | -- | -- | -- |
| 开销 | 大 | 小 | 中 |
| 速度 | 慢 | 快 | 中 |
| 并发 | 高 | 低 | 中 |
| 死锁 | 低 | 高 | 中 |


### 什么是死锁？怎么解决？

所谓死锁，是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。

常见的解决死锁的方法

- 如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。
- 在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；
- 对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；


### 什么是乐观锁？悲观锁？实现方式？

#### 悲观锁：

悲观锁指对数据被意外修改保守态度，依赖数据库原生支持的锁机制来保证当前事务处理的安全性，防止其他并发事务对目标数据的破坏或破坏其他并发事务数据，将在事务开始执行前或执行中申请锁定，执行完后再释放锁定。这对于长事务来讲，可能会严重影响系统的并发处理能力。自带的数据库事务就是典型的悲观锁。

#### 乐观锁：

乐观锁（Optimistic Lock），顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。乐观锁适用于读多写少的应用场景，这样可以提高吞吐量。一般是加一个版本号字段 每次更新时候比较版本号。


### 聚集索引与非聚集索引？

- 聚集索引 : 该索引中键值的逻辑顺序决定了表中相应行的物理顺序
- 非聚集索引 : 该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同

| 动作描述 | 使用聚集索引 | 使用非聚集索引 |
| -- | -- | -- |
| 列经常被分组排序 | 应 | 应 |
| 返回某范围内的数据 | 应 | 不应 |
| 一个或极少不同值 | 不应 | 不应 |
| 小数目的不同值 | 应 | 不应 |
| 大数目的不同值 | 不应 | 应 |
| 频繁更新的列 | 不应 | 应 |
| 外键列 | 应 | 应 |
| 主键列 | 应 | 应 |
| 频繁修改索引列 | 不应 | 应 |


### Mysql都有哪些索引？

- 普通索引 : 最基本的索引，没有任何限制。 ```  CREATE INDEX index_name ON table(column(length)) ```
- 唯一索引 : 与"普通索引"类似，不同的就是：索引列的值必须唯一，但允许有空值。  ``` CREATE UNIQUE INDEX indexName ON table(column(length)) ```
- 全文索引 : 仅可用于 MyISAM 表，针对较大的数据，生成全文索引很耗时好空间。 ``` CREATE FULLTEXT INDEX index_content ON article(content) ```
- 组合索引(最左前缀) : 为了更多的提高mysql效率可建立组合索引，遵循”最左前缀“原则。

### 索引算法有那些？有什么区别

索引算法有BTree,Hash

**BTree** 

BTree是最常用的mysql数据库索引算法，也是mysql默认的算法。因为它不仅可以被用在=,>,>=,<,<=和between这些操作符上，而且还可以用于like操作符，只要它的查询条件是一个不以通配符开头的常量。

例如:

    select * from user where name like 'test%'

如果以通配符开头，或者没有使用常量，则不会使用索引，例如：

    select * from user where name like '%test'


**Hash**

Hash索引只能用于对等比较，例如=,<=>(相当于=)操作符，由于是一次定位数据，不想BTree索引需要从根结点到枝节点，最后才能访问到页节点。这样多次IO访问，所以检索效率远高于BTree索引。

### 什么是事务？

事务是一个最小不可再分割的单位，具有原子性、一致性、隔离性、持久性4大特征。

- 原子性：事务是最小单位，不可再分割
- 一致性：事务执行过程中的DML操作，要么都成功、要么都失败
- 隔离性：事务A和事务B之间具有隔离性
- 持久性：事务最终操作的记录能写到数据库中，持久化

### 什么是脏读？什么是幻读？不可重复读？

- 脏读：一个事务访问到另一个事务读取未提交的数据

| 会话1 | 会话2 |
| -- | -- |
| begin | begin |
| - | update student set age = 10 where id = 1 |
| select age from student where id = 1 | - |
| commit | commit |

- 幻读：一个事务读取2次得到的记录条数不一致

| 会话1 | 会话2 |
| -- | -- |
| begin | begin |
| select count(1) from student where id > 10 |  |
| - | insert into student (id , age) values (2,10) |
| - | commit |
| select count(1) from student where id > 10 | - |
| commit | - |


- 不可重复读：一个事务读取同一条记录2次，得到的结果不一致

| 会话1 | 会话2 |
| -- | -- |
| begin | begin |
| select age from student where id =1 | - |
| - | update student age = 10 where id = 1 |
| - | commit |
| select age from student where id = 1 | - |
| commit | - |


### Mysql数据隔离级别

| 隔离级别 | 脏读 | 幻读 | 不可重复读 |
| -- | -- | -- | -- |
| 读取未提交 | ☑️ | ☑️ | ☑️ |
| 读取已提交 | x | ☑️ | ☑️ |
| 可重复读 | x | x | ☑️ |
| 可串行化 | x | x | x |