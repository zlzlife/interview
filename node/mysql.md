# MySql整理面试题汇总

- [Mysql常见的存储引擎有几种？分别有什么区别？](#Mysql常见的存储引擎有几种？分别有什么区别？)
- [Mysql都有哪些锁？什么业务下使用合适？](#Mysql都有哪些锁？什么业务下使用合适？)
- [什么是死锁？怎么解决？](#什么是死锁？怎么解决？)
- [什么是乐观锁？悲观锁？实现方式？](#什么是乐观锁？悲观锁？实现方式？)

### Mysql常见的存储引擎有几种？分别有什么区别？

1. InnoDB：支持行级锁定、支持事务、支持外键约束，支持自动增长列；不支持全文检索 (5.5.8之后是默认存储引擎)
2. MyISAM：全表锁，不支持事务、不支持外键，读写速度快、支持全文检索 (5.5.8之前是默认存储引擎)
3. Memory：全表锁，将表数据存储在内存中，表结构以文件存于磁盘中。访问速度非常快，数据在MySQL重启或崩溃时会丢失。要求存储数据长度不可变

| 功能 | MyISAM | Memory | InnoDB |
| -- | -- | -- | -- |
| 存储限制 | 256TB | RAM | 64TB |
| 支持事务 | No | No | Yes |
| 支持全文检索 | Yes | No | No |
| 支持数索引 | Yes | Yes | Yes |
| 支持哈希索引 | No | Yes | No |
| 支持数据缓存 | No | N/A | Yes |
| 支持外键 | No | No | Yes | 

使用场景：

- InnoDB：
    - 需要事务支持(具有较好的事务特性)
    - 行级锁定对高并发有很好的适应能力，但需要确保查询是通过索引完成
    - 数据更新较为频繁的场景
    - 数据一致性要求高
    - 硬件设备内存较大，可以利用InnoDB较好的缓存能力来提高内存利用率，尽可能减少磁盘IO

- MyISAM：
    - 不需要事务支持(不支持)
    - 并发相对较低(锁定机制问题)
    - 数据修改相对较少(阻塞问题)
    - 以读为主
    - 数据一致性要求不是非常高

- Memory：
    - 数据安全性要求不高
    - 一次性数据
    - 读写速度要求非常快
    - 需要建立一个临时查询的表


### Mysql都有哪些锁？什么业务下使用合适？

在DBMS中，按照颗粒程度可以把分为行级锁(InnoDB引擎)、表级锁(MyISAM引擎)、页级锁定(BDB引擎)

1. 行级锁

    a) 描述：Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行锁定。行级锁能大大减少数据库操作的冲突，其加锁粒度最小，但加锁的开销最大。行级锁分别为**共享锁**和**排他锁**

    b) 特点：开销大，加锁慢，会出现死锁。发生锁冲突的概率低，并发度也最高。

2. 表级锁

    a) 描述：mysql中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分mysql引擎支持。最常使用的MyISAM与InnoDB都支持表级锁定。表级锁分别为**共享锁**和**排他锁**

    b) 特点：开销小，加锁快，不会出现死锁。发生锁冲突的概率最高，并发度也最低。

3. 页级锁

    a) 描述：页级锁是MySQL中锁定粒度介于行级锁与表级锁中间的一种锁。但冲突多，行级冲突少，速度慢

    b) 特点：开销和加锁时间介于表锁和行锁之间；会出现死锁；锁定粒度介于表锁和行锁之间，并发度一般


| | 行级锁 | 表级锁 | 页级锁 |
| -- | -- | -- | -- |
| 开销 | 大 | 小 | 中 |
| 速度 | 慢 | 快 | 中 |
| 并发 | 高 | 低 | 中 |
| 死锁 | 低 | 高 | 中 |


### 什么是死锁？怎么解决？

所谓死锁，是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。

常见的解决死锁的方法

- 如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。
- 在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；
- 对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；


### 什么是乐观锁？悲观锁？实现方式？

#### 悲观锁：

悲观锁指对数据被意外修改保守态度，依赖数据库原生支持的锁机制来保证当前事务处理的安全性，防止其他并发事务对目标数据的破坏或破坏其他并发事务数据，将在事务开始执行前或执行中申请锁定，执行完后再释放锁定。这对于长事务来讲，可能会严重影响系统的并发处理能力。自带的数据库事务就是典型的悲观锁。

#### 乐观锁：

乐观锁（Optimistic Lock），顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。乐观锁适用于读多写少的应用场景，这样可以提高吞吐量。一般是加一个版本号字段 每次更新时候比较版本号。